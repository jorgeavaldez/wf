#!/bin/bash

DB_PATH="${WF_DB_PATH:-/wf.db}"

show_help() {
    echo "wf - Workflow Manager CLI"
    echo "Usage:"
    echo "  $0 add task \"task description\" [tag1,tag2,tag3...]"
    echo "  $0 dump task <task_id>"
    echo "  $0 delete task <task_id>"
    echo "  $0 list tasks [--all] [--count N] [tag]"
    echo "  $0 add thread <thread_id> \"summary\" [resolved] [tag1,tag2,tag3...]"
    echo "  $0 show thread <thread_id>"
    echo "  $0 list threads [--all] [--count N] [tag]"
    echo "  $0 add artifact <file_path|-> [name] [--summarize] [tag1,tag2,tag3...]"
    echo "  $0 link artifact <artifact_id> thread <thread_id>"
    echo "  $0 summarize artifact <artifact_id>"
    echo "  $0 dump artifact <artifact_id>"
    echo "  $0 delete artifact <artifact_id>"
    echo "  $0 list artifacts [--all] [--count N] [tag]"
    echo "  $0 add prompt <file_path|-> [name] [--summarize] [tag1,tag2,tag3...]"
    echo "  $0 show prompt <prompt_id>"
    echo "  $0 list prompts [--all] [--count N] [tag]"
    echo "  $0 update prompt <prompt_id> --name \"new name\" --content \"new content\" --description \"new desc\""
    echo "  $0 delete prompt <prompt_id>"
    echo "  $0 summarize prompt <prompt_id>"
    echo "  $0 dump prompt <prompt_id>"
    echo "  $0 link prompt <prompt_id> task <task_id>"
    echo "  $0 tag <type> <id> [tag1,tag2,tag3...]"
    echo "  $0 tool overview"
    echo "  $0 init <db_path>"
    echo ""
    echo "Examples:"
    echo "  $0 add task \"Fix login bug\" urgent,frontend"
    echo "  $0 dump task 1"
    echo "  $0 delete task 1"
    echo "  $0 list tasks"
    echo "  $0 list tasks urgent"
    echo "  $0 add thread \"abc123\" \"Login discussion\" false bug,discussion"
    echo "  $0 show thread \"abc123\""
    echo "  $0 list threads"
    echo "  $0 list threads bug"
    echo "  $0 add artifact \"plan.md\" --summarize documentation,planning"
    echo "  echo \"content\" | $0 add artifact - \"my-doc\" documentation,planning"
    echo "  $0 link artifact 1 thread \"abc123\""
    echo "  $0 summarize artifact 1"
    echo "  $0 dump artifact 1"
    echo "  $0 delete artifact 1"
    echo "  $0 list artifacts"
    echo "  $0 list artifacts documentation"
    echo "  $0 add prompt \"prompt.md\" --summarize security,review"
    echo "  echo \"prompt text\" | $0 add prompt - \"my-prompt\" security,review"
    echo "  $0 show prompt 1"
    echo "  $0 list prompts security"
    echo "  $0 update prompt 1 --content \"Please review this code for security and performance\""
    echo "  $0 delete prompt 1"
    echo "  $0 summarize prompt 1"
    echo "  $0 dump prompt 1"
    echo "  $0 link prompt 1 task 5"
    echo "  $0 tag task 1 urgent,priority"
    echo "  $0 tag thread \"abc123\" resolved"
    echo "  $0 tag artifact 1 outdated"
    echo "  $0 tag prompt 1 favorite,security"
    echo "  $0 tool overview"
    echo "  $0 init ~/my-wf.db"
}

migrate_search() {
    echo "Running FTS5 search migration..."

    # Check if SQLite has FTS5 support
    FTS5_SUPPORT=$(sqlite3 "$DB_PATH" "PRAGMA compile_options;" 2>/dev/null | grep -c "ENABLE_FTS5" || echo "0")
    if [ "$FTS5_SUPPORT" -eq 0 ]; then
        echo "Error: SQLite FTS5 not available. Please install SQLite with FTS5 support."
        echo "On macOS: brew install sqlite"
        echo "On Ubuntu/Debian: apt-get install sqlite3"
        exit 1
    fi

    # Ensure meta table exists
    sqlite3 "$DB_PATH" "CREATE TABLE IF NOT EXISTS wf_meta (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );"

    # Check if migration already applied
    MIGRATION_APPLIED=$(sqlite3 "$DB_PATH" "SELECT value FROM wf_meta WHERE key='migration:fts_search_v1';" 2>/dev/null || echo "")
    if [ "$MIGRATION_APPLIED" = "applied" ]; then
        echo "FTS search migration already applied."
        exit 0
    fi

    echo "Creating FTS tables and triggers..."

    # Create FTS tables and triggers in a transaction
    sqlite3 "$DB_PATH" <<'EOF'
BEGIN;

-- Create FTS5 virtual tables
CREATE VIRTUAL TABLE IF NOT EXISTS fts_tasks USING fts5(note, content='tasks', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_threads USING fts5(thread_id, summary, content='amp_threads', content_rowid='rowid');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_artifacts USING fts5(filename, summary, content, content='artifacts', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_prompts USING fts5(name, description, content, content='prompts', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_tags USING fts5(label, content='tags', content_rowid='id');

-- Create triggers for tasks
CREATE TRIGGER IF NOT EXISTS tasks_ai AFTER INSERT ON tasks BEGIN
  INSERT INTO fts_tasks(rowid, note) VALUES (new.id, new.note);
END;

CREATE TRIGGER IF NOT EXISTS tasks_ad AFTER DELETE ON tasks BEGIN
  INSERT INTO fts_tasks(fts_tasks, rowid, note) VALUES('delete', old.id, old.note);
END;

CREATE TRIGGER IF NOT EXISTS tasks_au AFTER UPDATE ON tasks BEGIN
  INSERT INTO fts_tasks(fts_tasks, rowid, note) VALUES('delete', old.id, old.note);
  INSERT INTO fts_tasks(rowid, note) VALUES (new.id, new.note);
END;

-- Create triggers for threads
CREATE TRIGGER IF NOT EXISTS amp_threads_ai AFTER INSERT ON amp_threads BEGIN
  INSERT INTO fts_threads(rowid, thread_id, summary)
  VALUES (new.rowid, new.thread_id, new.summary);
END;

CREATE TRIGGER IF NOT EXISTS amp_threads_ad AFTER DELETE ON amp_threads BEGIN
  INSERT INTO fts_threads(fts_threads, rowid, thread_id, summary)
  VALUES ('delete', old.rowid, old.thread_id, old.summary);
END;

CREATE TRIGGER IF NOT EXISTS amp_threads_au AFTER UPDATE ON amp_threads BEGIN
  INSERT INTO fts_threads(fts_threads, rowid, thread_id, summary)
  VALUES ('delete', old.rowid, old.thread_id, old.summary);
  INSERT INTO fts_threads(rowid, thread_id, summary)
  VALUES (new.rowid, new.thread_id, new.summary);
END;

-- Create triggers for artifacts
CREATE TRIGGER IF NOT EXISTS artifacts_ai AFTER INSERT ON artifacts BEGIN
  INSERT INTO fts_artifacts(rowid, filename, summary, content)
  VALUES (new.id, new.filename, new.summary, new.content);
END;

CREATE TRIGGER IF NOT EXISTS artifacts_ad AFTER DELETE ON artifacts BEGIN
  INSERT INTO fts_artifacts(fts_artifacts, rowid, filename, summary, content)
  VALUES ('delete', old.id, old.filename, old.summary, old.content);
END;

CREATE TRIGGER IF NOT EXISTS artifacts_au AFTER UPDATE ON artifacts BEGIN
  INSERT INTO fts_artifacts(fts_artifacts, rowid, filename, summary, content)
  VALUES ('delete', old.id, old.filename, old.summary, old.content);
  INSERT INTO fts_artifacts(rowid, filename, summary, content)
  VALUES (new.id, new.filename, new.summary, new.content);
END;

-- Create triggers for prompts
CREATE TRIGGER IF NOT EXISTS prompts_ai AFTER INSERT ON prompts BEGIN
  INSERT INTO fts_prompts(rowid, name, description, content)
  VALUES (new.id, new.name, new.description, new.content);
END;

CREATE TRIGGER IF NOT EXISTS prompts_ad AFTER DELETE ON prompts BEGIN
  INSERT INTO fts_prompts(fts_prompts, rowid, name, description, content)
  VALUES ('delete', old.id, old.name, old.description, old.content);
END;

CREATE TRIGGER IF NOT EXISTS prompts_au AFTER UPDATE ON prompts BEGIN
  INSERT INTO fts_prompts(fts_prompts, rowid, name, description, content)
  VALUES ('delete', old.id, old.name, old.description, old.content);
  INSERT INTO fts_prompts(rowid, name, description, content)
  VALUES (new.id, new.name, new.description, new.content);
END;

-- Create triggers for tags
CREATE TRIGGER IF NOT EXISTS tags_ai AFTER INSERT ON tags BEGIN
  INSERT INTO fts_tags(rowid, label) VALUES (new.id, new.label);
END;

CREATE TRIGGER IF NOT EXISTS tags_ad AFTER DELETE ON tags BEGIN
  INSERT INTO fts_tags(fts_tags, rowid, label) VALUES('delete', old.id, old.label);
END;

CREATE TRIGGER IF NOT EXISTS tags_au AFTER UPDATE ON tags BEGIN
  INSERT INTO fts_tags(fts_tags, rowid, label) VALUES('delete', old.id, old.label);
  INSERT INTO fts_tags(rowid, label) VALUES (new.id, new.label);
END;

COMMIT;
EOF

    if [ $? -ne 0 ]; then
        echo "Error: Failed to create FTS tables and triggers"
        exit 1
    fi

    # Check if FTS tables are empty and backfill if needed
    TASKS_COUNT=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM fts_tasks;" 2>/dev/null || echo "0")
    if [ "$TASKS_COUNT" -eq 0 ]; then
        echo "Backfilling existing data..."

        sqlite3 "$DB_PATH" <<'EOF'
BEGIN;
-- Backfill FTS tables from existing data
INSERT INTO fts_tasks(rowid, note) SELECT id, note FROM tasks;
INSERT INTO fts_threads(rowid, thread_id, summary) SELECT rowid, thread_id, summary FROM amp_threads;
INSERT INTO fts_artifacts(rowid, filename, summary, content) SELECT id, filename, summary, content FROM artifacts;
INSERT INTO fts_prompts(rowid, name, description, content) SELECT id, name, description, content FROM prompts;
INSERT INTO fts_tags(rowid, label) SELECT id, label FROM tags;
COMMIT;
EOF

        if [ $? -ne 0 ]; then
            echo "Error: Failed to backfill FTS data"
            exit 1
        fi
        echo "Backfill completed successfully."
    else
        echo "FTS tables already contain data, skipping backfill."
    fi

    # Record migration applied and update schema version
    sqlite3 "$DB_PATH" "
        INSERT INTO wf_meta(key,value) VALUES('migration:fts_search_v1','applied')
        ON CONFLICT(key) DO UPDATE SET value='applied', updated_at=CURRENT_TIMESTAMP;
        INSERT INTO wf_meta(key,value) VALUES('schema_version','2')
        ON CONFLICT(key) DO UPDATE SET value='2', updated_at=CURRENT_TIMESTAMP;
    "

    echo "FTS search migration completed successfully!"
}

init_database() {
    if [ $# -eq 0 ]; then
        echo "Error: Database path required"
        show_help
        exit 1
    fi

    NEW_DB_PATH="$1"

    # Expand ~ to full path if needed
    NEW_DB_PATH="${NEW_DB_PATH/#\~/$HOME}"

    # Check if file already exists
    if [ -f "$NEW_DB_PATH" ]; then
        echo "Error: Database file already exists at '$NEW_DB_PATH'"
        exit 1
    fi

    # Create directory if it doesn't exist
    DB_DIR=$(dirname "$NEW_DB_PATH")
    if [ ! -d "$DB_DIR" ]; then
        mkdir -p "$DB_DIR"
        echo "Created directory: $DB_DIR"
    fi

    echo "Creating new database at: $NEW_DB_PATH"

    # Create all the tables with the same schema as the existing database
    sqlite3 "$NEW_DB_PATH" <<'EOF'
-- Core tables
CREATE TABLE amp_threads (
    thread_id TEXT PRIMARY KEY NOT NULL, 
    summary TEXT, 
    resolved BOOLEAN DEFAULT FALSE
);

CREATE TABLE tasks (
    id INTEGER PRIMARY KEY, 
    note TEXT NOT NULL
);

CREATE TABLE tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    label TEXT UNIQUE NOT NULL
);

CREATE TABLE artifacts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    filename TEXT NOT NULL,
    content TEXT NOT NULL,
    summary TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE prompts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    content TEXT NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Junction tables for many-to-many relationships
CREATE TABLE task_tags (
    task_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (task_id, tag_id),
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

CREATE TABLE thread_tags (
    thread_id TEXT NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (thread_id, tag_id),
    FOREIGN KEY (thread_id) REFERENCES amp_threads(thread_id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

CREATE TABLE artifact_task_links (
    artifact_id INTEGER NOT NULL,
    task_id INTEGER NOT NULL,
    PRIMARY KEY (artifact_id, task_id),
    FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE TABLE artifact_thread_links (
    artifact_id INTEGER NOT NULL,
    thread_id TEXT NOT NULL,
    PRIMARY KEY (artifact_id, thread_id),
    FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE,
    FOREIGN KEY (thread_id) REFERENCES amp_threads(thread_id) ON DELETE CASCADE
);

CREATE TABLE artifact_tags (
    artifact_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (artifact_id, tag_id),
    FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

CREATE TABLE prompt_tags (
    prompt_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (prompt_id, tag_id),
    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

CREATE TABLE prompt_task_links (
    prompt_id INTEGER NOT NULL,
    task_id INTEGER NOT NULL,
    PRIMARY KEY (prompt_id, task_id),
    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE TABLE prompt_thread_links (
    prompt_id INTEGER NOT NULL,
    thread_id TEXT NOT NULL,
    PRIMARY KEY (prompt_id, thread_id),
    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
    FOREIGN KEY (thread_id) REFERENCES amp_threads(thread_id) ON DELETE CASCADE
);

CREATE TABLE prompt_artifact_links (
    prompt_id INTEGER NOT NULL,
    artifact_id INTEGER NOT NULL,
    PRIMARY KEY (prompt_id, artifact_id),
    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,
    FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE
);

-- Migration/version tracking
CREATE TABLE IF NOT EXISTS wf_meta (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- FTS5 virtual tables
CREATE VIRTUAL TABLE IF NOT EXISTS fts_tasks USING fts5(note, content='tasks', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_threads USING fts5(thread_id, summary, content='amp_threads', content_rowid='rowid');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_artifacts USING fts5(filename, summary, content, content='artifacts', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_prompts USING fts5(name, description, content, content='prompts', content_rowid='id');
CREATE VIRTUAL TABLE IF NOT EXISTS fts_tags USING fts5(label, content='tags', content_rowid='id');

-- Triggers to keep FTS in sync with base tables
-- Tasks triggers
CREATE TRIGGER IF NOT EXISTS tasks_ai AFTER INSERT ON tasks BEGIN
  INSERT INTO fts_tasks(rowid, note) VALUES (new.id, new.note);
END;

CREATE TRIGGER IF NOT EXISTS tasks_ad AFTER DELETE ON tasks BEGIN
  INSERT INTO fts_tasks(fts_tasks, rowid, note) VALUES('delete', old.id, old.note);
END;

CREATE TRIGGER IF NOT EXISTS tasks_au AFTER UPDATE ON tasks BEGIN
  INSERT INTO fts_tasks(fts_tasks, rowid, note) VALUES('delete', old.id, old.note);
  INSERT INTO fts_tasks(rowid, note) VALUES (new.id, new.note);
END;

-- Threads triggers
CREATE TRIGGER IF NOT EXISTS amp_threads_ai AFTER INSERT ON amp_threads BEGIN
  INSERT INTO fts_threads(rowid, thread_id, summary)
  VALUES (new.rowid, new.thread_id, new.summary);
END;

CREATE TRIGGER IF NOT EXISTS amp_threads_ad AFTER DELETE ON amp_threads BEGIN
  INSERT INTO fts_threads(fts_threads, rowid, thread_id, summary)
  VALUES ('delete', old.rowid, old.thread_id, old.summary);
END;

CREATE TRIGGER IF NOT EXISTS amp_threads_au AFTER UPDATE ON amp_threads BEGIN
  INSERT INTO fts_threads(fts_threads, rowid, thread_id, summary)
  VALUES ('delete', old.rowid, old.thread_id, old.summary);
  INSERT INTO fts_threads(rowid, thread_id, summary)
  VALUES (new.rowid, new.thread_id, new.summary);
END;

-- Artifacts triggers
CREATE TRIGGER IF NOT EXISTS artifacts_ai AFTER INSERT ON artifacts BEGIN
  INSERT INTO fts_artifacts(rowid, filename, summary, content)
  VALUES (new.id, new.filename, new.summary, new.content);
END;

CREATE TRIGGER IF NOT EXISTS artifacts_ad AFTER DELETE ON artifacts BEGIN
  INSERT INTO fts_artifacts(fts_artifacts, rowid, filename, summary, content)
  VALUES ('delete', old.id, old.filename, old.summary, old.content);
END;

CREATE TRIGGER IF NOT EXISTS artifacts_au AFTER UPDATE ON artifacts BEGIN
  INSERT INTO fts_artifacts(fts_artifacts, rowid, filename, summary, content)
  VALUES ('delete', old.id, old.filename, old.summary, old.content);
  INSERT INTO fts_artifacts(rowid, filename, summary, content)
  VALUES (new.id, new.filename, new.summary, new.content);
END;

-- Prompts triggers
CREATE TRIGGER IF NOT EXISTS prompts_ai AFTER INSERT ON prompts BEGIN
  INSERT INTO fts_prompts(rowid, name, description, content)
  VALUES (new.id, new.name, new.description, new.content);
END;

CREATE TRIGGER IF NOT EXISTS prompts_ad AFTER DELETE ON prompts BEGIN
  INSERT INTO fts_prompts(fts_prompts, rowid, name, description, content)
  VALUES ('delete', old.id, old.name, old.description, old.content);
END;

CREATE TRIGGER IF NOT EXISTS prompts_au AFTER UPDATE ON prompts BEGIN
  INSERT INTO fts_prompts(fts_prompts, rowid, name, description, content)
  VALUES ('delete', old.id, old.name, old.description, old.content);
  INSERT INTO fts_prompts(rowid, name, description, content)
  VALUES (new.id, new.name, new.description, new.content);
END;

-- Tags triggers
CREATE TRIGGER IF NOT EXISTS tags_ai AFTER INSERT ON tags BEGIN
  INSERT INTO fts_tags(rowid, label) VALUES (new.id, new.label);
END;

CREATE TRIGGER IF NOT EXISTS tags_ad AFTER DELETE ON tags BEGIN
  INSERT INTO fts_tags(fts_tags, rowid, label) VALUES('delete', old.id, old.label);
END;

CREATE TRIGGER IF NOT EXISTS tags_au AFTER UPDATE ON tags BEGIN
  INSERT INTO fts_tags(fts_tags, rowid, label) VALUES('delete', old.id, old.label);
  INSERT INTO fts_tags(rowid, label) VALUES (new.id, new.label);
END;

-- Set baseline schema version for new databases
INSERT INTO wf_meta(key,value) VALUES('schema_version','2')
ON CONFLICT(key) DO UPDATE SET value='2', updated_at=CURRENT_TIMESTAMP;
EOF

    if [ $? -eq 0 ]; then
        echo "Database successfully created at: $NEW_DB_PATH"
        echo ""
        echo "To use this database, set the WF_DB_PATH environment variable:"
        echo "  export WF_DB_PATH=\"$NEW_DB_PATH\""
        echo ""
        echo "Add this to your ~/.zshrc to make it permanent:"
        echo "  echo 'export WF_DB_PATH=\"$NEW_DB_PATH\"' >> ~/.zshrc"
    else
        echo "Error: Failed to create database"
        exit 1
    fi
}

add_task() {
    if [ $# -eq 0 ]; then
        echo "Error: Task description required"
        show_help
        exit 1
    fi

    TASK_NOTE="$1"
    TAGS="$2"

    # Escape single quotes for SQL
    TASK_NOTE_ESCAPED=$(echo "$TASK_NOTE" | sed "s/'/''/g")

    # Insert the task and get its ID
    TASK_ID=$(sqlite3 "$DB_PATH" "INSERT INTO tasks (note) VALUES ('$TASK_NOTE_ESCAPED'); SELECT last_insert_rowid();")

    echo "Added task #$TASK_ID: $TASK_NOTE"

    # Process tags if provided
    if [ -n "$TAGS" ]; then
        IFS=',' read -ra TAG_ARRAY <<<"$TAGS"
        for tag in "${TAG_ARRAY[@]}"; do
            # Trim whitespace
            tag=$(echo "$tag" | xargs)

            # Escape single quotes in tag
            tag_escaped=$(echo "$tag" | sed "s/'/''/g")

            # Insert tag if it doesn't exist, get its ID
            TAG_ID=$(sqlite3 "$DB_PATH" "
                INSERT OR IGNORE INTO tags (label) VALUES ('$tag_escaped');
                SELECT id FROM tags WHERE label = '$tag_escaped';
            ")

            # Link task to tag
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO task_tags (task_id, tag_id) VALUES ($TASK_ID, $TAG_ID);"
            echo "  Tagged with: $tag"
        done
    fi
}

delete_task() {
    if [ $# -eq 0 ]; then
        echo "Error: Task ID required"
        show_help
        exit 1
    fi

    TASK_ID="$1"

    # Check if task exists
    TASK_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM tasks WHERE id = $TASK_ID;")
    if [ "$TASK_EXISTS" -eq 0 ]; then
        echo "Error: Task #$TASK_ID not found"
        exit 1
    fi

    # Get task description for confirmation
    TASK_NOTE=$(sqlite3 "$DB_PATH" "SELECT note FROM tasks WHERE id = $TASK_ID;")

    # Delete the task (CASCADE will handle related records)
    sqlite3 "$DB_PATH" "DELETE FROM tasks WHERE id = $TASK_ID;"

    echo "Deleted task #$TASK_ID: $TASK_NOTE"
}

add_thread() {
    if [ $# -lt 2 ]; then
        echo "Error: Thread ID and summary required"
        show_help
        exit 1
    fi

    THREAD_ID="$1"
    SUMMARY="$2"
    RESOLVED="${3:-false}"
    TAGS="$4"

    # Escape single quotes for SQL
    THREAD_ID_ESCAPED=$(echo "$THREAD_ID" | sed "s/'/''/g")
    SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed "s/'/''/g")

    # Insert the thread
    sqlite3 "$DB_PATH" "INSERT OR REPLACE INTO amp_threads (thread_id, summary, resolved) VALUES ('$THREAD_ID_ESCAPED', '$SUMMARY_ESCAPED', $RESOLVED);"

    echo "Added thread $THREAD_ID: $SUMMARY (resolved: $RESOLVED)"

    # Process tags if provided
    if [ -n "$TAGS" ]; then
        IFS=',' read -ra TAG_ARRAY <<<"$TAGS"
        for tag in "${TAG_ARRAY[@]}"; do
            # Trim whitespace
            tag=$(echo "$tag" | xargs)

            # Escape single quotes in tag
            tag_escaped=$(echo "$tag" | sed "s/'/''/g")

            # Insert tag if it doesn't exist, get its ID
            TAG_ID=$(sqlite3 "$DB_PATH" "
                INSERT OR IGNORE INTO tags (label) VALUES ('$tag_escaped');
                SELECT id FROM tags WHERE label = '$tag_escaped';
            ")

            # Link thread to tag
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO thread_tags (thread_id, tag_id) VALUES ('$THREAD_ID_ESCAPED', $TAG_ID);"
            echo "  Tagged with: $tag"
        done
    fi
}

dump_task() {
    if [ $# -eq 0 ]; then
        echo "Error: Task ID required"
        show_help
        exit 1
    fi

    TASK_ID="$1"

    # Get task with tags
    RESULT=$(sqlite3 "$DB_PATH" "
        SELECT t.id, t.note, GROUP_CONCAT(g.label) as tags
        FROM tasks t
        LEFT JOIN task_tags tt ON t.id = tt.task_id
        LEFT JOIN tags g ON tt.tag_id = g.id
        WHERE t.id = $TASK_ID
        GROUP BY t.id, t.note;
    ")

    if [ -z "$RESULT" ]; then
        echo "Task #$TASK_ID not found"
        exit 1
    fi

    echo "$RESULT" | while IFS='|' read -r id note tags; do
        echo "Task #$id"
        echo "Note: $note"
        if [ -n "$tags" ]; then
            echo "Tags: $tags"
        else
            echo "Tags: none"
        fi
    done
}

list_tasks() {
    # Parse arguments
    SHOW_ALL=false
    COUNT=""
    TAG_FILTER=""

    while [ $# -gt 0 ]; do
        case "$1" in
            "--all")
                SHOW_ALL=true
                shift
                ;;
            "--count")
                if [ -z "$2" ] || ! echo "$2" | grep -q '^[0-9][0-9]*$'; then
                    echo "Error: --count requires a positive integer"
                    exit 1
                fi
                COUNT="$2"
                shift 2
                ;;
            *)
                # Treat as tag filter if not empty and doesn't start with --
                if [ -n "$1" ] && [ "${1#--}" = "$1" ]; then
                    TAG_FILTER="$1"
                fi
                shift
                ;;
        esac
    done

    # Set default limit if neither --all nor --count specified
    if [ "$SHOW_ALL" = false ] && [ -z "$COUNT" ]; then
        COUNT="5"
    fi

    # Build LIMIT clause
    LIMIT_CLAUSE=""
    if [ "$SHOW_ALL" = false ] && [ -n "$COUNT" ]; then
        LIMIT_CLAUSE="LIMIT $COUNT"
    fi

    if [ -n "$TAG_FILTER" ]; then
        # Parse multiple tags separated by commas
        IFS=',' read -ra FILTER_TAGS <<<"$TAG_FILTER"
        TAG_COUNT=${#FILTER_TAGS[@]}

        # Build WHERE conditions for multiple tags (AND logic)
        TAG_CONDITIONS=""
        for i in "${!FILTER_TAGS[@]}"; do
            tag=$(echo "${FILTER_TAGS[$i]}" | xargs)    # trim whitespace
            tag_escaped=$(echo "$tag" | sed "s/'/''/g") # escape single quotes
            if [ $i -gt 0 ]; then
                TAG_CONDITIONS="$TAG_CONDITIONS AND "
            fi
            TAG_CONDITIONS="${TAG_CONDITIONS}t.id IN (SELECT tt${i}.task_id FROM task_tags tt${i} JOIN tags g${i} ON tt${i}.tag_id = g${i}.id WHERE g${i}.label = '$tag_escaped')"
        done

        # Get tasks filtered by multiple tags (must have ALL specified tags)
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT t.id, t.note, GROUP_CONCAT(g.label) as tags
            FROM tasks t
            LEFT JOIN task_tags tt ON t.id = tt.task_id
            LEFT JOIN tags g ON tt.tag_id = g.id
            WHERE $TAG_CONDITIONS
            GROUP BY t.id, t.note
            ORDER BY t.id DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No tasks found with tag '$TAG_FILTER'"
            exit 0
        fi

        echo "Tasks tagged with '$TAG_FILTER':"
        echo "==============================="
    else
        # Get all tasks with tags
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT t.id, t.note, GROUP_CONCAT(g.label) as tags
            FROM tasks t
            LEFT JOIN task_tags tt ON t.id = tt.task_id
            LEFT JOIN tags g ON tt.tag_id = g.id
            GROUP BY t.id, t.note
            ORDER BY t.id DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No tasks found"
            exit 0
        fi

        echo "All Tasks:"
        echo "=========="
    fi

    echo "$RESULT" | while IFS='|' read -r id note tags; do
        echo "[#$id] $note"
        if [ -n "$tags" ]; then
            echo "  Tags: $tags"
        else
            echo "  Tags: none"
        fi
        echo ""
    done
}

show_thread() {
    if [ $# -eq 0 ]; then
        echo "Error: Thread ID required"
        show_help
        exit 1
    fi

    THREAD_ID="$1"

    # Escape single quotes for SQL
    THREAD_ID_ESCAPED=$(echo "$THREAD_ID" | sed "s/'/''/g")

    # Get thread with tags
    RESULT=$(sqlite3 "$DB_PATH" "
        SELECT t.thread_id, t.summary, t.resolved, GROUP_CONCAT(g.label) as tags
        FROM amp_threads t
        LEFT JOIN thread_tags tt ON t.thread_id = tt.thread_id
        LEFT JOIN tags g ON tt.tag_id = g.id
        WHERE t.thread_id = '$THREAD_ID_ESCAPED'
        GROUP BY t.thread_id, t.summary, t.resolved;
    ")

    if [ -z "$RESULT" ]; then
        echo "Thread $THREAD_ID not found"
        exit 1
    fi

    echo "$RESULT" | while IFS='|' read -r thread_id summary resolved tags; do
        echo "Thread: $thread_id"
        echo "Summary: $summary"
        echo "Resolved: $resolved"
        if [ -n "$tags" ]; then
            echo "Tags: $tags"
        else
            echo "Tags: none"
        fi
    done
}

list_threads() {
    # Parse arguments
    SHOW_ALL=false
    COUNT=""
    TAG_FILTER=""

    while [ $# -gt 0 ]; do
        case "$1" in
            "--all")
                SHOW_ALL=true
                shift
                ;;
            "--count")
                if [ -z "$2" ] || ! echo "$2" | grep -q '^[0-9][0-9]*$'; then
                    echo "Error: --count requires a positive integer"
                    exit 1
                fi
                COUNT="$2"
                shift 2
                ;;
            *)
                # Treat as tag filter if not empty and doesn't start with --
                if [ -n "$1" ] && [ "${1#--}" = "$1" ]; then
                    TAG_FILTER="$1"
                fi
                shift
                ;;
        esac
    done

    # Set default limit if neither --all nor --count specified
    if [ "$SHOW_ALL" = false ] && [ -z "$COUNT" ]; then
        COUNT="5"
    fi

    # Build LIMIT clause
    LIMIT_CLAUSE=""
    if [ "$SHOW_ALL" = false ] && [ -n "$COUNT" ]; then
        LIMIT_CLAUSE="LIMIT $COUNT"
    fi

    if [ -n "$TAG_FILTER" ]; then
        # Parse multiple tags separated by commas
        IFS=',' read -ra FILTER_TAGS <<<"$TAG_FILTER"
        TAG_COUNT=${#FILTER_TAGS[@]}

        # Build WHERE conditions for multiple tags (AND logic)
        TAG_CONDITIONS=""
        for i in "${!FILTER_TAGS[@]}"; do
            tag=$(echo "${FILTER_TAGS[$i]}" | xargs)    # trim whitespace
            tag_escaped=$(echo "$tag" | sed "s/'/''/g") # escape single quotes
            if [ $i -gt 0 ]; then
                TAG_CONDITIONS="$TAG_CONDITIONS AND "
            fi
            TAG_CONDITIONS="${TAG_CONDITIONS}t.thread_id IN (SELECT tt${i}.thread_id FROM thread_tags tt${i} JOIN tags g${i} ON tt${i}.tag_id = g${i}.id WHERE g${i}.label = '$tag_escaped')"
        done

        # Get threads filtered by multiple tags (must have ALL specified tags)
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT t.thread_id, t.summary, t.resolved, GROUP_CONCAT(g.label) as tags
            FROM amp_threads t
            LEFT JOIN thread_tags tt ON t.thread_id = tt.thread_id
            LEFT JOIN tags g ON tt.tag_id = g.id
            WHERE $TAG_CONDITIONS
            GROUP BY t.thread_id, t.summary, t.resolved
            ORDER BY t.thread_id DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No threads found with tag '$TAG_FILTER'"
            exit 0
        fi

        echo "Threads tagged with '$TAG_FILTER':"
        echo "=================================="
    else
        # Get all threads with tags and summaries
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT t.thread_id, t.summary, t.resolved, GROUP_CONCAT(g.label) as tags
            FROM amp_threads t
            LEFT JOIN thread_tags tt ON t.thread_id = tt.thread_id
            LEFT JOIN tags g ON tt.tag_id = g.id
            GROUP BY t.thread_id, t.summary, t.resolved
            ORDER BY t.thread_id DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No threads found"
            exit 0
        fi

        echo "All Threads:"
        echo "============"
    fi

    echo "$RESULT" | while IFS='|' read -r thread_id summary resolved tags; do
        echo "[$thread_id] $summary (resolved: $resolved)"
        if [ -n "$tags" ]; then
            echo "  Tags: $tags"
        else
            echo "  Tags: none"
        fi
        echo ""
    done
}

add_artifact() {
    if [ $# -eq 0 ]; then
        echo "Error: File path or '-' for stdin required"
        show_help
        exit 1
    fi

    FILE_PATH="$1"
    TAGS=""
    SUMMARIZE=false

    # Check if using stdin
    if [ "$FILE_PATH" = "-" ] || [ "$FILE_PATH" = "--stdin" ]; then
        # Check if stdin has data available
        if [ -t 0 ]; then
            echo "Error: No stdin data available"
            exit 1
        fi

        # Parse arguments for stdin mode (filename is optional second argument)
        FILENAME="${2:-stdin-content}"
        shift 2 2>/dev/null || shift # Handle case where only one argument provided

        # Parse remaining arguments
        while [ $# -gt 0 ]; do
            case "$1" in
                "--summarize")
                    SUMMARIZE=true
                    shift
                    ;;
                *)
                    if [ -z "$TAGS" ]; then
                        TAGS="$1"
                    fi
                    shift
                    ;;
            esac
        done

        # Read from stdin and escape single quotes for SQL
        CONTENT=$(cat | sed "s/'/''/g")
        FILENAME=$(echo "$FILENAME" | sed "s/'/''/g")
    else
        # Parse arguments to handle --summarize flag
        shift
        while [ $# -gt 0 ]; do
            case "$1" in
                "--summarize")
                    SUMMARIZE=true
                    shift
                    ;;
                *)
                    if [ -z "$TAGS" ]; then
                        TAGS="$1"
                    fi
                    shift
                    ;;
            esac
        done

        # Check if file exists
        if [ ! -f "$FILE_PATH" ]; then
            echo "Error: File '$FILE_PATH' not found"
            exit 1
        fi

        # Get filename from path and escape single quotes for SQL
        FILENAME=$(basename "$FILE_PATH" | sed "s/'/''/g")

        # Read file content and escape single quotes for SQL
        CONTENT=$(cat "$FILE_PATH" | sed "s/'/''/g")
    fi

    # Insert the artifact and get its ID
    ARTIFACT_ID=$(sqlite3 "$DB_PATH" "INSERT INTO artifacts (filename, content) VALUES ('$FILENAME', '$CONTENT'); SELECT last_insert_rowid();")

    echo "Added artifact #$ARTIFACT_ID: $FILENAME"

    # Auto-summarize if flag is set
    if [ "$SUMMARIZE" = true ]; then
        echo "Generating summary for artifact #$ARTIFACT_ID..."

        # Generate summary using claude CLI with retry logic
        for attempt in 1 2; do
            SUMMARY=$(echo "$CONTENT" | sed "s/''/'/g" | claude -p "Provide exactly one title sentence or phrase that summarizes this markdown content:")

            if [ $? -eq 0 ] && validate_single_line_summary "$SUMMARY"; then
                # Escape single quotes for SQL
                SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed "s/'/''/g")
                # Update the summary field
                sqlite3 "$DB_PATH" "UPDATE artifacts SET summary = '$SUMMARY_ESCAPED' WHERE id = $ARTIFACT_ID;"
                echo "  Summary: $SUMMARY"
                break
            elif [ $? -eq 0 ]; then
                echo "  Warning: Summary attempt $attempt produced multiple lines, retrying..."
            else
                echo "  Warning: Claude CLI failed on attempt $attempt"
            fi

            if [ $attempt -eq 2 ]; then
                echo "  Warning: Failed to generate valid single-line summary after 2 attempts"
            fi
        done
    fi

    # Process tags if provided
    if [ -n "$TAGS" ]; then
        IFS=',' read -ra TAG_ARRAY <<<"$TAGS"
        for tag in "${TAG_ARRAY[@]}"; do
            # Trim whitespace
            tag=$(echo "$tag" | xargs)

            # Escape single quotes in tag
            tag_escaped=$(echo "$tag" | sed "s/'/''/g")

            # Insert tag if it doesn't exist, get its ID
            TAG_ID=$(sqlite3 "$DB_PATH" "
                INSERT OR IGNORE INTO tags (label) VALUES ('$tag_escaped');
                SELECT id FROM tags WHERE label = '$tag_escaped';
            ")

            # Link artifact to tag
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO artifact_tags (artifact_id, tag_id) VALUES ($ARTIFACT_ID, $TAG_ID);"
            echo "  Tagged with: $tag"
        done
    fi
}

link_artifact() {
    if [ $# -lt 3 ]; then
        echo "Error: artifact_id, link_type, and target_id required"
        show_help
        exit 1
    fi

    ARTIFACT_ID="$1"
    LINK_TYPE="$2"
    TARGET_ID="$3"

    case "$LINK_TYPE" in
        "thread")
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO artifact_thread_links (artifact_id, thread_id) VALUES ($ARTIFACT_ID, '$TARGET_ID');"
            echo "Linked artifact #$ARTIFACT_ID to thread $TARGET_ID"
            ;;
        "task")
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO artifact_task_links (artifact_id, task_id) VALUES ($ARTIFACT_ID, $TARGET_ID);"
            echo "Linked artifact #$ARTIFACT_ID to task #$TARGET_ID"
            ;;
        *)
            echo "Error: Link type must be 'thread' or 'task'"
            exit 1
            ;;
    esac
}

summarize_artifact() {
    if [ $# -eq 0 ]; then
        echo "Error: Artifact ID required"
        show_help
        exit 1
    fi

    ARTIFACT_ID="$1"

    # Get artifact content
    CONTENT=$(sqlite3 "$DB_PATH" "SELECT content FROM artifacts WHERE id = $ARTIFACT_ID;")

    if [ -z "$CONTENT" ]; then
        echo "Artifact #$ARTIFACT_ID not found"
        exit 1
    fi

    echo "Generating summary for artifact #$ARTIFACT_ID..."

    # Generate summary using claude CLI with retry logic
    for attempt in 1 2; do
        SUMMARY=$(echo "$CONTENT" | claude -p "Provide exactly one title sentence or phrase that summarizes this markdown content:")

        if [ $? -eq 0 ] && validate_single_line_summary "$SUMMARY"; then
            # Escape single quotes for SQL
            SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed "s/'/''/g")
            # Update the summary field
            sqlite3 "$DB_PATH" "UPDATE artifacts SET summary = '$SUMMARY_ESCAPED' WHERE id = $ARTIFACT_ID;"
            echo "Summary updated for artifact #$ARTIFACT_ID"
            echo "Summary: $SUMMARY"
            return 0
        elif [ $? -eq 0 ]; then
            echo "Warning: Summary attempt $attempt produced multiple lines, retrying..."
        else
            echo "Warning: Claude CLI failed on attempt $attempt"
        fi
    done

    echo "Error: Failed to generate valid single-line summary after 2 attempts"
    exit 1
}

dump_artifact() {
    if [ $# -eq 0 ]; then
        echo "Error: Artifact ID required"
        show_help
        exit 1
    fi

    ARTIFACT_ID="$1"

    # Get and output raw artifact content
    CONTENT=$(sqlite3 "$DB_PATH" "SELECT content FROM artifacts WHERE id = $ARTIFACT_ID;")

    if [ -z "$CONTENT" ]; then
        echo "Artifact #$ARTIFACT_ID not found" >&2
        exit 1
    fi

    echo "$CONTENT"
}

delete_artifact() {
    if [ $# -eq 0 ]; then
        echo "Error: Artifact ID required"
        show_help
        exit 1
    fi

    ARTIFACT_ID="$1"

    # Check if artifact exists
    ARTIFACT_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM artifacts WHERE id = $ARTIFACT_ID;")
    if [ "$ARTIFACT_EXISTS" -eq 0 ]; then
        echo "Error: Artifact #$ARTIFACT_ID not found"
        exit 1
    fi

    # Get artifact filename for confirmation
    ARTIFACT_FILENAME=$(sqlite3 "$DB_PATH" "SELECT filename FROM artifacts WHERE id = $ARTIFACT_ID;")

    # Delete the artifact (CASCADE will handle related records)
    sqlite3 "$DB_PATH" "DELETE FROM artifacts WHERE id = $ARTIFACT_ID;"

    echo "Deleted artifact #$ARTIFACT_ID: $ARTIFACT_FILENAME"
}

list_artifacts() {
    # Parse arguments
    SHOW_ALL=false
    COUNT=""
    TAG_FILTER=""

    while [ $# -gt 0 ]; do
        case "$1" in
            "--all")
                SHOW_ALL=true
                shift
                ;;
            "--count")
                if [ -z "$2" ] || ! echo "$2" | grep -q '^[0-9][0-9]*$'; then
                    echo "Error: --count requires a positive integer"
                    exit 1
                fi
                COUNT="$2"
                shift 2
                ;;
            *)
                # Treat as tag filter if not empty and doesn't start with --
                if [ -n "$1" ] && [ "${1#--}" = "$1" ]; then
                    TAG_FILTER="$1"
                fi
                shift
                ;;
        esac
    done

    # Set default limit if neither --all nor --count specified
    if [ "$SHOW_ALL" = false ] && [ -z "$COUNT" ]; then
        COUNT="5"
    fi

    # Build LIMIT clause
    LIMIT_CLAUSE=""
    if [ "$SHOW_ALL" = false ] && [ -n "$COUNT" ]; then
        LIMIT_CLAUSE="LIMIT $COUNT"
    fi

    if [ -n "$TAG_FILTER" ]; then
        # Parse multiple tags separated by commas
        IFS=',' read -ra FILTER_TAGS <<<"$TAG_FILTER"
        TAG_COUNT=${#FILTER_TAGS[@]}

        # Build WHERE conditions for multiple tags (AND logic)
        TAG_CONDITIONS=""
        for i in "${!FILTER_TAGS[@]}"; do
            tag=$(echo "${FILTER_TAGS[$i]}" | xargs)    # trim whitespace
            tag_escaped=$(echo "$tag" | sed "s/'/''/g") # escape single quotes
            if [ $i -gt 0 ]; then
                TAG_CONDITIONS="$TAG_CONDITIONS AND "
            fi
            TAG_CONDITIONS="${TAG_CONDITIONS}a.id IN (SELECT at${i}.artifact_id FROM artifact_tags at${i} JOIN tags g${i} ON at${i}.tag_id = g${i}.id WHERE g${i}.label = '$tag_escaped')"
        done

        # Get artifacts filtered by multiple tags (must have ALL specified tags)
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT a.id, a.filename, a.summary, GROUP_CONCAT(g.label) as tags, a.created_at
            FROM artifacts a
            LEFT JOIN artifact_tags at ON a.id = at.artifact_id
            LEFT JOIN tags g ON at.tag_id = g.id
            WHERE $TAG_CONDITIONS
            GROUP BY a.id, a.filename, a.summary, a.created_at
            ORDER BY a.created_at DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No artifacts found with tag '$TAG_FILTER'"
            exit 0
        fi

        echo "Artifacts tagged with '$TAG_FILTER':"
        echo "===================================="
    else
        # Get all artifacts with tags
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT a.id, a.filename, a.summary, GROUP_CONCAT(g.label) as tags, a.created_at
            FROM artifacts a
            LEFT JOIN artifact_tags at ON a.id = at.artifact_id
            LEFT JOIN tags g ON at.tag_id = g.id
            GROUP BY a.id, a.filename, a.summary, a.created_at
            ORDER BY a.created_at DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No artifacts found"
            exit 0
        fi

        echo "All Artifacts:"
        echo "=============="
    fi

    echo "$RESULT" | while IFS='|' read -r id filename summary tags created_at; do
        echo "[#$id] $filename"
        if [ -n "$summary" ] && [ "$summary" != "" ]; then
            echo "  Summary: $summary"
        fi
        if [ -n "$tags" ]; then
            echo "  Tags: $tags"
        else
            echo "  Tags: none"
        fi
        echo "  Created: $created_at"
        echo ""
    done
}

add_prompt() {
    if [ $# -eq 0 ]; then
        echo "Error: File path or '-' for stdin required"
        show_help
        exit 1
    fi

    FILE_PATH="$1"
    TAGS=""
    SUMMARIZE=false

    # Check if using stdin
    if [ "$FILE_PATH" = "-" ] || [ "$FILE_PATH" = "--stdin" ]; then
        # Check if stdin has data available
        if [ -t 0 ]; then
            echo "Error: No stdin data available"
            exit 1
        fi

        # Parse arguments for stdin mode (prompt name is optional second argument)
        PROMPT_NAME="${2:-stdin-prompt}"
        shift 2 2>/dev/null || shift # Handle case where only one argument provided

        # Parse remaining arguments
        while [ $# -gt 0 ]; do
            case "$1" in
                "--summarize")
                    SUMMARIZE=true
                    shift
                    ;;
                *)
                    if [ -z "$TAGS" ]; then
                        TAGS="$1"
                    fi
                    shift
                    ;;
            esac
        done

        # Read from stdin and escape single quotes for SQL
        PROMPT_CONTENT=$(cat | sed "s/'/''/g")
        PROMPT_NAME=$(echo "$PROMPT_NAME" | sed "s/'/''/g")
    else
        # Parse arguments to handle --summarize flag
        shift
        while [ $# -gt 0 ]; do
            case "$1" in
                "--summarize")
                    SUMMARIZE=true
                    shift
                    ;;
                *)
                    if [ -z "$TAGS" ]; then
                        TAGS="$1"
                    fi
                    shift
                    ;;
            esac
        done

        # Check if file exists
        if [ ! -f "$FILE_PATH" ]; then
            echo "Error: File '$FILE_PATH' not found"
            exit 1
        fi

        # Get filename from path and escape single quotes for SQL
        PROMPT_NAME=$(basename "$FILE_PATH" | sed "s/'/''/g")

        # Read file content and escape single quotes for SQL
        PROMPT_CONTENT=$(cat "$FILE_PATH" | sed "s/'/''/g")
    fi

    # Insert the prompt and get its ID
    PROMPT_ID=$(sqlite3 "$DB_PATH" "INSERT INTO prompts (name, content) VALUES ('$PROMPT_NAME', '$PROMPT_CONTENT'); SELECT last_insert_rowid();")

    echo "Added prompt #$PROMPT_ID: $PROMPT_NAME"

    # Auto-summarize if flag is set
    if [ "$SUMMARIZE" = true ]; then
        echo "Generating summary for prompt #$PROMPT_ID..."

        # Generate summary using claude CLI with retry logic
        for attempt in 1 2; do
            SUMMARY=$(echo "$PROMPT_CONTENT" | sed "s/''/'/g" | claude -p "I have given you a prompt I wrote for another agent as markdown. Provide exactly one title sentence or phrase that summarizes this markdown content:")

            if [ $? -eq 0 ] && validate_single_line_summary "$SUMMARY"; then
                # Escape single quotes for SQL
                SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed "s/'/''/g")
                # Update the description field with the summary
                sqlite3 "$DB_PATH" "UPDATE prompts SET description = '$SUMMARY_ESCAPED', updated_at = CURRENT_TIMESTAMP WHERE id = $PROMPT_ID;"
                echo "  Summary: $SUMMARY"
                break
            elif [ $? -eq 0 ]; then
                echo "  Warning: Summary attempt $attempt produced multiple lines, retrying..."
            else
                echo "  Warning: Claude CLI failed on attempt $attempt"
            fi

            if [ $attempt -eq 2 ]; then
                echo "  Warning: Failed to generate valid single-line summary after 2 attempts"
            fi
        done
    fi

    # Process tags if provided
    if [ -n "$TAGS" ]; then
        IFS=',' read -ra TAG_ARRAY <<<"$TAGS"
        for tag in "${TAG_ARRAY[@]}"; do
            # Trim whitespace
            tag=$(echo "$tag" | xargs)

            # Escape single quotes in tag
            tag_escaped=$(echo "$tag" | sed "s/'/''/g")

            # Insert tag if it doesn't exist, get its ID
            TAG_ID=$(sqlite3 "$DB_PATH" "
                INSERT OR IGNORE INTO tags (label) VALUES ('$tag_escaped');
                SELECT id FROM tags WHERE label = '$tag_escaped';
            ")

            # Link prompt to tag
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO prompt_tags (prompt_id, tag_id) VALUES ($PROMPT_ID, $TAG_ID);"
            echo "  Tagged with: $tag"
        done
    fi
}

show_prompt() {
    if [ $# -eq 0 ]; then
        echo "Error: Prompt ID required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"

    # Get prompt with tags
    RESULT=$(sqlite3 "$DB_PATH" "
        SELECT p.id, p.name, p.description, p.content, GROUP_CONCAT(g.label) as tags, p.created_at, p.updated_at
        FROM prompts p
        LEFT JOIN prompt_tags pt ON p.id = pt.prompt_id
        LEFT JOIN tags g ON pt.tag_id = g.id
        WHERE p.id = $PROMPT_ID
        GROUP BY p.id, p.name, p.description, p.content, p.created_at, p.updated_at;
    ")

    if [ -z "$RESULT" ]; then
        echo "Prompt #$PROMPT_ID not found"
        exit 1
    fi

    echo "$RESULT" | while IFS='|' read -r id name description content tags created_at updated_at; do
        echo "Prompt #$id: $name"
        if [ -n "$description" ] && [ "$description" != "" ]; then
            echo "Description: $description"
        fi
        echo "Content: $content"
        if [ -n "$tags" ]; then
            echo "Tags: $tags"
        else
            echo "Tags: none"
        fi
        echo "Created: $created_at"
        echo "Updated: $updated_at"
    done
}

list_prompts() {
    # Parse arguments
    SHOW_ALL=false
    COUNT=""
    TAG_FILTER=""

    while [ $# -gt 0 ]; do
        case "$1" in
            "--all")
                SHOW_ALL=true
                shift
                ;;
            "--count")
                if [ -z "$2" ] || ! echo "$2" | grep -q '^[0-9][0-9]*$'; then
                    echo "Error: --count requires a positive integer"
                    exit 1
                fi
                COUNT="$2"
                shift 2
                ;;
            *)
                # Treat as tag filter if not empty and doesn't start with --
                if [ -n "$1" ] && [ "${1#--}" = "$1" ]; then
                    TAG_FILTER="$1"
                fi
                shift
                ;;
        esac
    done

    # Set default limit if neither --all nor --count specified
    if [ "$SHOW_ALL" = false ] && [ -z "$COUNT" ]; then
        COUNT="5"
    fi

    # Build LIMIT clause
    LIMIT_CLAUSE=""
    if [ "$SHOW_ALL" = false ] && [ -n "$COUNT" ]; then
        LIMIT_CLAUSE="LIMIT $COUNT"
    fi

    if [ -n "$TAG_FILTER" ]; then
        # Parse multiple tags separated by commas
        IFS=',' read -ra FILTER_TAGS <<<"$TAG_FILTER"
        TAG_COUNT=${#FILTER_TAGS[@]}

        # Build WHERE conditions for multiple tags (AND logic)
        TAG_CONDITIONS=""
        for i in "${!FILTER_TAGS[@]}"; do
            tag=$(echo "${FILTER_TAGS[$i]}" | xargs)    # trim whitespace
            tag_escaped=$(echo "$tag" | sed "s/'/''/g") # escape single quotes
            if [ $i -gt 0 ]; then
                TAG_CONDITIONS="$TAG_CONDITIONS AND "
            fi
            TAG_CONDITIONS="${TAG_CONDITIONS}p.id IN (SELECT pt${i}.prompt_id FROM prompt_tags pt${i} JOIN tags g${i} ON pt${i}.tag_id = g${i}.id WHERE g${i}.label = '$tag_escaped')"
        done

        # Get prompts filtered by multiple tags (must have ALL specified tags)
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT p.id, p.name, SUBSTR(p.description, 1, INSTR(p.description || char(10), char(10)) - 1) as description, GROUP_CONCAT(g.label) as tags, p.created_at
            FROM prompts p
            LEFT JOIN prompt_tags pt ON p.id = pt.prompt_id
            LEFT JOIN tags g ON pt.tag_id = g.id
            WHERE $TAG_CONDITIONS
            GROUP BY p.id, p.name, p.description, p.created_at
            ORDER BY p.created_at DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No prompts found with tag '$TAG_FILTER'"
            exit 0
        fi

        echo "Prompts tagged with '$TAG_FILTER':"
        echo "================================="
    else
        # Get all prompts with tags
        RESULT=$(sqlite3 "$DB_PATH" "
            SELECT p.id, p.name, SUBSTR(p.description, 1, INSTR(p.description || char(10), char(10)) - 1) as description, GROUP_CONCAT(g.label) as tags, p.created_at
            FROM prompts p
            LEFT JOIN prompt_tags pt ON p.id = pt.prompt_id
            LEFT JOIN tags g ON pt.tag_id = g.id
            GROUP BY p.id, p.name, p.description, p.created_at
            ORDER BY p.created_at DESC
            $LIMIT_CLAUSE;
        ")

        if [ -z "$RESULT" ]; then
            echo "No prompts found"
            exit 0
        fi

        echo "All Prompts:"
        echo "==========="
    fi

    echo "$RESULT" | while IFS='|' read -r id name description tags created_at; do
        echo "[#$id] $name"
        if [ -n "$description" ] && [ "$description" != "" ]; then
            echo "  Description: $description"
        fi
        if [ -n "$tags" ] && [ "$tags" != "" ]; then
            echo "  Tags: $tags"
        else
            echo "  Tags: none"
        fi
        echo "  Created: $created_at"
        echo ""
    done
}

update_prompt() {
    if [ $# -lt 2 ]; then
        echo "Error: Prompt ID and at least one field to update required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"
    shift

    # Check if prompt exists
    PROMPT_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM prompts WHERE id = $PROMPT_ID;")
    if [ "$PROMPT_EXISTS" -eq 0 ]; then
        echo "Error: Prompt #$PROMPT_ID not found"
        exit 1
    fi

    # Parse update parameters
    while [ $# -gt 0 ]; do
        case "$1" in
            --name)
                if [ -z "$2" ]; then
                    echo "Error: --name requires a value"
                    exit 1
                fi
                NAME_ESCAPED=$(echo "$2" | sed "s/'/''/g")
                sqlite3 "$DB_PATH" "UPDATE prompts SET name = '$NAME_ESCAPED', updated_at = CURRENT_TIMESTAMP WHERE id = $PROMPT_ID;"
                echo "Updated name for prompt #$PROMPT_ID"
                shift 2
                ;;
            --content)
                if [ -z "$2" ]; then
                    echo "Error: --content requires a value"
                    exit 1
                fi
                CONTENT_ESCAPED=$(echo "$2" | sed "s/'/''/g")
                sqlite3 "$DB_PATH" "UPDATE prompts SET content = '$CONTENT_ESCAPED', updated_at = CURRENT_TIMESTAMP WHERE id = $PROMPT_ID;"
                echo "Updated content for prompt #$PROMPT_ID"
                shift 2
                ;;
            --description)
                DESCRIPTION_ESCAPED=$(echo "$2" | sed "s/'/''/g")
                sqlite3 "$DB_PATH" "UPDATE prompts SET description = '$DESCRIPTION_ESCAPED', updated_at = CURRENT_TIMESTAMP WHERE id = $PROMPT_ID;"
                echo "Updated description for prompt #$PROMPT_ID"
                shift 2
                ;;
            *)
                echo "Error: Unknown parameter '$1'"
                echo "Valid parameters: --name, --content, --description"
                exit 1
                ;;
        esac
    done
}

delete_prompt() {
    if [ $# -eq 0 ]; then
        echo "Error: Prompt ID required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"

    # Check if prompt exists
    PROMPT_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM prompts WHERE id = $PROMPT_ID;")
    if [ "$PROMPT_EXISTS" -eq 0 ]; then
        echo "Error: Prompt #$PROMPT_ID not found"
        exit 1
    fi

    # Get prompt name for confirmation
    PROMPT_NAME=$(sqlite3 "$DB_PATH" "SELECT name FROM prompts WHERE id = $PROMPT_ID;")

    # Delete the prompt (CASCADE will handle related records)
    sqlite3 "$DB_PATH" "DELETE FROM prompts WHERE id = $PROMPT_ID;"

    echo "Deleted prompt #$PROMPT_ID: $PROMPT_NAME"
}

summarize_prompt() {
    if [ $# -eq 0 ]; then
        echo "Error: Prompt ID required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"

    # Get prompt content
    CONTENT=$(sqlite3 "$DB_PATH" "SELECT content FROM prompts WHERE id = $PROMPT_ID;")

    if [ -z "$CONTENT" ]; then
        echo "Prompt #$PROMPT_ID not found"
        exit 1
    fi

    echo "Generating summary for prompt #$PROMPT_ID..."

    # Generate summary using claude CLI with retry logic
    for attempt in 1 2; do
        SUMMARY=$(echo "$CONTENT" | claude -p "I have given you a prompt I wrote for another agent as markdown. Provide exactly one title sentence or phrase that summarizes this markdown content:")

        if [ $? -eq 0 ] && validate_single_line_summary "$SUMMARY"; then
            # Escape single quotes for SQL
            SUMMARY_ESCAPED=$(echo "$SUMMARY" | sed "s/'/''/g")
            # Update the description field with the summary
            sqlite3 "$DB_PATH" "UPDATE prompts SET description = '$SUMMARY_ESCAPED', updated_at = CURRENT_TIMESTAMP WHERE id = $PROMPT_ID;"
            echo "Summary updated for prompt #$PROMPT_ID"
            echo "Summary: $SUMMARY"
            return 0
        elif [ $? -eq 0 ]; then
            echo "Warning: Summary attempt $attempt produced multiple lines, retrying..."
        else
            echo "Warning: Claude CLI failed on attempt $attempt"
        fi
    done

    echo "Error: Failed to generate valid single-line summary after 2 attempts"
    exit 1
}

dump_prompt() {
    if [ $# -eq 0 ]; then
        echo "Error: Prompt ID required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"

    # Get and output raw prompt content
    CONTENT=$(sqlite3 "$DB_PATH" "SELECT content FROM prompts WHERE id = $PROMPT_ID;")

    if [ -z "$CONTENT" ]; then
        echo "Prompt #$PROMPT_ID not found" >&2
        exit 1
    fi

    echo "$CONTENT"
}

link_prompt() {
    if [ $# -lt 3 ]; then
        echo "Error: prompt_id, link_type, and target_id required"
        show_help
        exit 1
    fi

    PROMPT_ID="$1"
    LINK_TYPE="$2"
    TARGET_ID="$3"

    case "$LINK_TYPE" in
        "task")
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO prompt_task_links (prompt_id, task_id) VALUES ($PROMPT_ID, $TARGET_ID);"
            echo "Linked prompt #$PROMPT_ID to task #$TARGET_ID"
            ;;
        "thread")
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO prompt_thread_links (prompt_id, thread_id) VALUES ($PROMPT_ID, '$TARGET_ID');"
            echo "Linked prompt #$PROMPT_ID to thread $TARGET_ID"
            ;;
        "artifact")
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO prompt_artifact_links (prompt_id, artifact_id) VALUES ($PROMPT_ID, $TARGET_ID);"
            echo "Linked prompt #$PROMPT_ID to artifact #$TARGET_ID"
            ;;
        *)
            echo "Error: Link type must be 'task', 'thread', or 'artifact'"
            exit 1
            ;;
    esac
}

validate_single_line_summary() {
    local summary="$1"
    local line_count=$(echo "$summary" | wc -l | xargs)

    if [ "$line_count" -ne 1 ]; then
        return 1
    fi

    # Additional check for empty lines or lines with only whitespace
    if [ -z "$(echo "$summary" | xargs)" ]; then
        return 1
    fi

    return 0
}

tag_entity() {
    if [ $# -lt 2 ]; then
        echo "Error: Entity type and ID required"
        show_help
        exit 1
    fi

    ENTITY_TYPE="$1"
    ENTITY_ID="$2"
    TAGS="$3"

    if [ -z "$TAGS" ]; then
        echo "Error: At least one tag required"
        show_help
        exit 1
    fi

    # Validate entity type and check if entity exists
    case "$ENTITY_TYPE" in
        "task")
            ENTITY_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM tasks WHERE id = $ENTITY_ID;")
            if [ "$ENTITY_EXISTS" -eq 0 ]; then
                echo "Error: Task #$ENTITY_ID not found"
                exit 1
            fi
            JUNCTION_TABLE="task_tags"
            FOREIGN_KEY="task_id"
            ;;
        "thread")
            ENTITY_ID_ESCAPED=$(echo "$ENTITY_ID" | sed "s/'/''/g")
            ENTITY_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM amp_threads WHERE thread_id = '$ENTITY_ID_ESCAPED';")
            if [ "$ENTITY_EXISTS" -eq 0 ]; then
                echo "Error: Thread $ENTITY_ID not found"
                exit 1
            fi
            JUNCTION_TABLE="thread_tags"
            FOREIGN_KEY="thread_id"
            ;;
        "artifact")
            ENTITY_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM artifacts WHERE id = $ENTITY_ID;")
            if [ "$ENTITY_EXISTS" -eq 0 ]; then
                echo "Error: Artifact #$ENTITY_ID not found"
                exit 1
            fi
            JUNCTION_TABLE="artifact_tags"
            FOREIGN_KEY="artifact_id"
            ;;
        "prompt")
            ENTITY_EXISTS=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM prompts WHERE id = $ENTITY_ID;")
            if [ "$ENTITY_EXISTS" -eq 0 ]; then
                echo "Error: Prompt #$ENTITY_ID not found"
                exit 1
            fi
            JUNCTION_TABLE="prompt_tags"
            FOREIGN_KEY="prompt_id"
            ;;
        *)
            echo "Error: Entity type must be 'task', 'thread', 'artifact', or 'prompt'"
            exit 1
            ;;
    esac

    echo "Adding tags to $ENTITY_TYPE $ENTITY_ID:"

    # Process tags
    IFS=',' read -ra TAG_ARRAY <<<"$TAGS"
    for tag in "${TAG_ARRAY[@]}"; do
        # Trim whitespace
        tag=$(echo "$tag" | xargs)

        # Escape single quotes in tag
        tag_escaped=$(echo "$tag" | sed "s/'/''/g")

        # Insert tag if it doesn't exist, get its ID
        TAG_ID=$(sqlite3 "$DB_PATH" "
            INSERT OR IGNORE INTO tags (label) VALUES ('$tag_escaped');
            SELECT id FROM tags WHERE label = '$tag_escaped';
        ")

        # Link entity to tag based on type
        if [ "$ENTITY_TYPE" = "thread" ]; then
            # Thread IDs are text, need quotes and escaping
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO $JUNCTION_TABLE ($FOREIGN_KEY, tag_id) VALUES ('$ENTITY_ID_ESCAPED', $TAG_ID);"
        else
            # Task, artifact, and prompt IDs are integers, no quotes
            sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO $JUNCTION_TABLE ($FOREIGN_KEY, tag_id) VALUES ($ENTITY_ID, $TAG_ID);"
        fi

        echo "  Tagged with: $tag"
    done
}

tool_overview() {
    cat <<'EOF'
WF TOOL OVERVIEW FOR AGENTIC CODING

Purpose: Track work across coding sessions, maintain AI conversation context, store development artifacts and reusable prompts with flexible tagging and linking.

CORE ENTITIES:
1. Tasks - Work items/backlog: wf add task "description" [tags] | wf list tasks [tag] | wf dump task <id>
2. Threads - AI conversations: wf add thread "id" "summary" [resolved] [tags] | wf list threads [tag]
3. Artifacts - Documents/code: wf add artifact "file.md" [tags] | wf dump artifact <id> | wf summarize artifact <id>
4. Prompts - Reusable AI prompts: wf add prompt "file.md" [tags] | wf summarize prompt <id> | wf list prompts [tag]
5. Tags - Auto-created labels for filtering: urgent,backend,bug,resolved,project-a

KEY COMMANDS:
wf add task "Fix login" urgent,backend
wf add thread "conv123" "Fixed OAuth bug" true bug,resolved  
wf add artifact "design.md" architecture,planning
wf add prompt "code-review.md" security,review
echo "content" | wf add artifact - "stdin-doc" temp
pbpaste | wf add prompt - "clipboard-prompt" review
wf summarize prompt 1
wf link artifact 1 thread "conv123"
wf link prompt 1 task 5
wf list tasks urgent
wf list threads resolved
wf list prompts security
wf dump artifact 1 | claude "analyze this"
wf dump prompt 1 | claude
wf tag task 1 blocked,high
wf update prompt 1 --content "New prompt text"

WORKFLOW PATTERNS:
Feature Development:
- wf add task "New feature" feature,high
- wf add artifact "design.md" feature,planning
- echo "Review implementation approach" | wf add prompt - "feature-review" feature,review
- wf add thread "conv456" "Discussed implementation" false feature
- wf link artifact 1 task 1; wf link prompt 1 task 1; wf link artifact 1 thread "conv456"

Bug Tracking:
- wf add task "Session timeout bug" bug,urgent
- wf add thread "debug789" "Found config issue" true bug,resolved
- wf add artifact "fix.md" bug,solution
- wf add prompt "bug-analysis.md" debugging,analysis
- Link all together with link commands

Prompt Library Management:
- wf add prompt "security-review.md" security,review
- wf add prompt "performance-audit.md" performance,optimization
- wf add prompt "code-quality.md" quality,standards
- wf list prompts security
- wf dump prompt 2 | claude "Additional context here"

Project Organization:
- Use project tags: project-a,project-b
- Filter everything: wf list tasks project-a, wf list prompts project-a
- Technology tags: react,python,docker
- Status tags: blocked,testing,done
- Prompt categories: security,performance,debugging,review

BEST PRACTICES:
- Always log significant AI conversations as threads
- Store all design docs, solutions, notes as artifacts  
- Build a reusable prompt library for common tasks
- Link prompts to related tasks/threads/artifacts for context
- Use consistent tagging: component,type,priority,status
- Mark threads resolved when complete
- Reference artifact/prompt IDs in commit messages and code comments
- Pipe content to AI: wf dump artifact 5 | claude "prompt" or wf dump prompt 3 | claude
- Update prompts as you refine them: wf update prompt 1 --content "improved version"
- Use stdin for quick content: pbpaste | wf add artifact - "clipboard" temp
- From editors: :'<,'>w !wf add artifact - "buffer-content" coding

PROMPT MANAGEMENT:
- Create templates: wf add prompt "api-review.md" api,template
- Version control: Use descriptive names and update existing prompts rather than duplicating
- Context linking: Link prompts to tasks/artifacts they're commonly used with
- Tag consistently: security,performance,debugging,review,analysis,template

COMMON TAGS: urgent,high,low | frontend,backend,api,database | bug,feature,refactor | blocked,testing,resolved | react,python,sql | security,performance,debugging,review,analysis,template

The system becomes more valuable with consistent use - every stored artifact, logged thread, and reusable prompt creates richer context for future AI interactions.
EOF
}

# Handle space-separated commands (convert to dash format for compatibility)
COMMAND="$1"
if [ $# -ge 2 ]; then
    case "$1 $2" in
        "list tasks" | "list threads" | "list artifacts" | "list prompts")
            COMMAND="$1-$2"
            shift
            ;;
        "add task" | "add thread" | "add artifact" | "add prompt")
            COMMAND="$1-$2"
            shift
            ;;
        "dump task" | "delete task" | "show thread" | "show prompt")
            COMMAND="$1-$2"
            shift
            ;;
        "link artifact" | "link prompt")
            COMMAND="$1-$2"
            shift
            ;;
        "summarize artifact" | "summarize prompt")
            COMMAND="$1-$2"
            shift
            ;;
        "dump artifact" | "dump prompt")
            COMMAND="$1-$2"
            shift
            ;;
        "delete artifact")
            COMMAND="$1-$2"
            shift
            ;;
        "update prompt" | "delete prompt" | "delete task")
            COMMAND="$1-$2"
            shift
            ;;
        "tool overview")
            COMMAND="tool-overview"
            shift
            ;;
        "migrate search")
            COMMAND="migrate-search"
            shift
            ;;
    esac
fi

# Main command dispatch
case "$COMMAND" in
    "add-task")
        shift
        add_task "$@"
        ;;
    "dump-task")
        shift
        dump_task "$@"
        ;;
    "delete-task")
        shift
        delete_task "$@"
        ;;
    "list-tasks")
        shift
        list_tasks "$@"
        ;;
    "add-thread")
        shift
        add_thread "$@"
        ;;
    "show-thread")
        shift
        show_thread "$@"
        ;;
    "list-threads")
        shift
        list_threads "$@"
        ;;
    "add-artifact")
        shift
        add_artifact "$@"
        ;;
    "link-artifact")
        shift
        link_artifact "$@"
        ;;
    "summarize-artifact")
        shift
        summarize_artifact "$@"
        ;;
    "dump-artifact")
        shift
        dump_artifact "$@"
        ;;
    "delete-artifact")
        shift
        delete_artifact "$@"
        ;;
    "list-artifacts")
        shift
        list_artifacts "$@"
        ;;
    "add-prompt")
        shift
        add_prompt "$@"
        ;;
    "show-prompt")
        shift
        show_prompt "$@"
        ;;
    "list-prompts")
        shift
        list_prompts "$@"
        ;;
    "update-prompt")
        shift
        update_prompt "$@"
        ;;
    "delete-prompt")
        shift
        delete_prompt "$@"
        ;;
    "summarize-prompt")
        shift
        summarize_prompt "$@"
        ;;
    "dump-prompt")
        shift
        dump_prompt "$@"
        ;;
    "link-prompt")
        shift
        link_prompt "$@"
        ;;
    "tag")
        shift
        tag_entity "$@"
        ;;
    "tool-overview")
        tool_overview
        ;;
    "init")
        shift
        init_database "$@"
        ;;
    "migrate-search")
        migrate_search
        ;;
    *)
        show_help
        ;;
esac
